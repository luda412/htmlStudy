코딩 자율 학습 Java Script 파트

# 변수와 상수

변수는 값이 변하는 데이터를 저장하고 관리하기 위한 공간으로 변수를 생성함.

## 키워드

어떤 역할이나 기능이 정해진 특별한 언어(예약어)

## 식별자

변수, 함수 등에 부여되는 이름을 의미한다. 변수는 컴퓨터의 메모리라는 곳에 저장.

## 표현식

하나의 값을 반환하는 식 또는 코드를 의미

## 값

더 이상 평가할 수 없는 데이터를 의미

## 선언, 할당

변수의 식별자를 지정하는 행위를 변수를 선언한다고 한다. 연산자인 = 기호로 우변에 있는 값을 변수 공간에 대입하는 것을 값을 할당한다고 한다. 

## 초기화

선언과 할당을 한 번에 하는 것을 변수를 초기화 한다고 한다. 

## let

1. 변수명 중복이 불가능 하다.
2. 호이스팅 되지 않는다.
3. 스코프의 범위가 다르다. 

## 상수 const

1. 변수명 중복이 불가능 하다.
2. 호이스팅 되지 않는다.
3. 스코프의 범위가 다르다.
4. 재할당 불가능 하다. (선언과 할당을 분리하는 것도 불가능)

## 식별자 표기법

카멜 케이스: 변수명과 함수명 작성시 사용 Ex) firstName, lastName
언더스코어 케이스: 상수명 작성시 사용 Ex) FIRST_NAME, last_name
파스칼 케이스: 생성자 함수명 작성시 사용 Ex) FistName, LastName

# 자료형

데이터의 종류를 의미한다. 자료형으로는 string, number, boolean, undefined, null, Symbol, reference(참조), object

## 문자열

탬플릿 문자열은 백틱으로 문자열을 정의하는 방법.

## 숫자형

정수와 실수를 구분하지 않고 전부 하나의 숫자 자료형으로 취급한다. 

## 논리형

true, false를 의미, 연산으로도 구할 수 있다.

## undefined

할당하지 않을 경우 JS 내부적으로 변수와 상수 공간에 임시로 데이터를 할당, 그때의 값이 undefined이다. 

## null

변수나 상수를 선언하고 의도적으로 선언한 공간을 비워 둘 때 할당한다.

## object

파생되는 자료형으로는 배열, 객체 리터럴, 함수가 있다.

### 배열

1. 복수의 데이터를 정의할 수 있는 자료형
2. 배열로 정의한 데이터를 요소라고 한다. 
3. 배열에서 각 데이터가 있는 위치를 가리키는 숫자를 인덱스라고 한다. 
4. 배열은 모든 자료형을 저장할 수 있다. 
5. 비어있는 배열을 정의할 수 있다.

### 객체 리터럴

객체를 정의하는 가장 간단한 방법이며 객체를 정의할 때 중괄호를 사용하며, 중괄호 항에는 키(key), 값(value)의 한쌍으로 이루어진 속성(property)가 들어간다. 
배열과는 다르게 값을 인덱스가 아닌 키로 구분한다. 

# 연산자

= 할당 연산자

## 산술 연산자

수학 연산을 수행하는 연산자를 말한다.

## 비교 연산자

비교 연산자는 피연산자를 비교한 뒤, 논리형 값인 ture와 false를 반환하는 연산을 수핸한다.

== 값이 같으면 true를 반환한다.
=== 값과 자료형이 같으면 ture를 반환한다.
!= 값이 다르면 true를 반환한다.
!== 값과 자료형이 다르면 true를 반환한다.

## 논리 연산자

x && y -> x가 참이면 y를 반환하고 x가 거짓이면 x를 반환
x || y -> x가 참이면 x를 반환하고 x가 거짓이면 y를 반환
!x -> x가 참이면 false를 반환하고 x가 거짓이면 true를 반환

특징: 어떤 피연산자든 모두 논리형으로 평가한다. 

### &&

피연산자를 왼쪽부터 평가해 평가 결과가 거짓이면 거짓이 나온 피연산자를 즉시 반환하고, 거짓이 아니면 마지막 피연산자를 반환한다.

### ||

피연산자를 왼쪽부터 평가해 참으로 평가된 피연산자를 즉시 반환한다. 만약 모든 피연산자가 참으로 평가되지 않으면 마지막 피연산자를 반환

## 삼항 연산자

세 항 중 가장 왼쪽에 있는 피연산자의 참, 거짓에 따라 나머지 두 항에 있는 피연산자를 선택적으로 반환하는 연산을 수행한다. 

Ex) x ? y : z -> x가 참이면 y를 반환하고 x가 거짓이면 z를 반환한다.

## 형 변환

데이터의 자료형이 다른 자료형으로 바뀌는 것을 말한다.

암시적 형 변환: 예제 참조

명시적 형 변환: 드러나게 형 변환, 예제 참조

# 조건문

## if 문

조건식이 참으로 평가되면 중괄호 안의 코드를 실행하는 조건문.
조건식은 숫자를 써도, 문자열을 써도, undefined를 써도, null을 써도 무조건 참/거짓으로 평가한다.

## else if 문

문의 개수에는 제한이 없지만 항상 if문 다음에 else가 와야한다.

## 중첩 문

어떤 조건식을 만족할 때 어떤 블록문을 실행할지 결정하는 것을 분기 처리라고 한다. 반복적으로 사용하지 말 것

## switch 문

switch 뒤에 오는 소괄호 안의 값과 일치하는 case 문이 있을 때 해당 코드를 실행하는 조건문. 값과 자료형을 함께 비교한다. switch문에는 하나 이상의 case문과 default문, break문을 사용한다.

## if문과 조건식

논리 연산자나 비교 연산자를 식에 이용해서 사용, 예제 참조

# 반복문

지정한 조건이 참으로 평가되는 동안 지정한 블록문을 실행하는 문법

## while문

특정 조건을 만족하는 동안 블롣문을 실행

## 무한 반복문

반복문의 조건이 계속 참으로 평가되어 반복문이 끝나지 않고 무한히 실행되는 것을 말한다.
조건이 거짓이 되는 순간이 있는지 신경 써야 한다.

## do...while 문

측정 조건이 참으로 평가되는 동안 do 다음에 오는 블록문을 반복 실행한다.
while 문은 블록문을 수행하기 전에 조건식을 평가한다. 반면 do...while문은 블록문을 한 번 수행한 후에 조건식을 평가한다는 특징이 있다.

## for 문

횟수를 지정해 지정한 횟수가 끝날 때까지 블록문을 반복 실행하는 반복문으로 조건식과 증감식이라는 실행구조가 있다.

## for문과 배열

for문은 횟수를 지정하는 반복문이라는 특징 때문에 배열과 같은 자료형을 반복 횟수 용도로 사용할 수 있다. 

## for in

소괄호 안에 in 키워드를 두고 키워드의 오른쪽에는 탐색의 대상이 되는 배열 또는 객체 리터럴, 왼쪽에는 배열 또는 객체 리터럴을 탐색해서 키를 저장할 변수를 놓는다.

## breack 문

인위적으로 반복문을 종료하는 방법이 있다. 어떤 반복문이라도 break문을 만나면 반복문이 종료된다.

## continue 문

break문은 반복문을 즉시 종료하는 명령이라면, continue문은 방복문을 건너뛰고 실행하라는 명령이다. 반복문에서 continue문을 만나면 해당 반복 실행만 건너뛰게 된다. 

# 함수 function

어떤 목적을 가지고 작성한 코드를 모아 둔 블록문이다. 코드를 함수로 만들면 함수를 호출해 함수 내부에 모아 둔 여러 줄의 코드를 한 번에 실행할 수 있다. 재사용하기 매우 편하다.
블록문을 function 키워드, 식별자, 소괄호와 함께 묶으면 함수가 생겅되는데, 이를 함수를 정의 한다고 한다.

## 함수를 정의하는 방법

함수 선언문, 함수 표현식, 화살표 함수를 정의해서 사용한다.

### 함수 선언문

function 키워드로 함수를 정의하는 방법. function 키워드 다음에 함수를 식별할 수 있도록 식별자를 붙이면 된다. 이때, 식별자 뒤에는 소괄호를 붙인다. 

### 함수 표현식

객체에서 파생된 자료형이다. 함수도 변수에 할당할 수 있는데, 이를 이용한 함수 정의 방법을 함수 표현식이라고 한다. 함수 표현식은 변수에 할당하는 함수에 식별자가 있으면 네이밍 함수, 없으면 익명함수.
function 키워드 다음에 오는 식별자로 함수를 호출하지 않고, 할당한 변수명으로 호출한다.
만약 function 키워드 다음에 오는 함수 식별자를 호출하면 안됨.
```
//Ex)
const gugudan = function naming(){};

gugudan(); //이렇게 호출해야함
naming(); // not definec 에러 발생
```
함수를 정의할 때는 const로 정의하는 것이 좋다. 이유: 일관된 목적을 가진 코드 집합이라서 재정의해서도, 재할당 해서도 안되는 경우가 많기 때문이다.

### 화살표 함수

화살표 함수는 익명함수로만 정의할 수 있어서 함수를 호출하려면 정의된 함수를 변수에 할당하는 방법인 함수 표현식을 사용해야한다. 

```
Ex)
const gugudan = () => {}; // 익명함수기 때문에 표현식처럼 함수 선언
gugudan(); // 변수명으로 호출해야함.
```

# 함수 기능 확장

## 매개변수와 인수

매개변수는 함수를 정의할 때 외부에서 전달하는 데이터를 함수에서 받을 수 있도록 정의하는 변수이다. 정의한 함수를 호출할 때 소괄호 안에서 전달하고 싶은 데이터를 적는데, 이를 인수라고 한다. 함수 호출 시 전달하는 데이터 즉, 인수는 함수의 매개변수에 자동으로 할당 된다.

## 매개변수 특징

- 매개변수는 일반적으로 변수와 같다고 생각하면 된다. 
- 데이터 전달: 함수를 정의할 때 함께 정의한 매개변수는 함수 호출시 전달되는 데이터와 일대일로 대응되어 데이터가 할당된다. 함수를 호출할 때 데이터를 전달하지만, 매개변수가 정의되지 않은 경우에는 오류를 발생하진 않는다. 값을 반환해서 사용할 수 없다.
- 기본값 할당: 매개변수에 직접 데이터를 할당하는 방식으로 단순하게 기본값을 지정할 수 있다. ```function sum(a = 1, b = 2)```

## return 문

함수 외부로 데이터를 반환할 때는 return 문을 사용해야한다. 반환된 데이터를 함수 외부에서 사용하려면 함수 호출 부분에서 반환값을 다시 변수에 할당해야한다. return문에 꼭 변수를 사용해야 하는 건 아니고 표현식으로도 데이터를 반환할 수 있다. 데이터를 반환하지 않으면 단순히 함수 실행을 종료하는 역할만 하게 된다.

# 함수 특징 이해하기

## 스코프

스코프는 변수나 함수와 같은 참조 대상 식별자를 찾아내기 위한 규칙

### 함수 스코프

함수에서 정의한 블록문만 스코프의 유효 범위로 인정하는 방식, 함수 내부는 지역 스코프, 함수 외부는 전역 스코프 영역이 된다. 전역 스코프는 스코프와 상관없이 모두 참조 가능하다. 하지만 함수 내부에서 선언한 변수는 지역(local)스코프이기 때문에 함수 외부에서 참조하려면 오류를 발생시킨다.

### 블록 스코프

let, const로 선언한 변수에 한해서만 적용된다. var는 내부나 외부나 오류를 발생시키지 않는다.(블록스코프에서) 

### 참조 우선순위

let, const 키워드는 같은 식별자의 중복 선언이 불가능하다. 정확히는 같은 스코프 영역에서 중복 선언이 불가능하다. 전역 스코프와 지역 스코프에 같은 식별자를 가지는 참조 대상이 있다면, 먼저 같은 지역 스코프의 식별자를 참조한다. 그리고 같은 지역 스코프에서 참조할 식별자를 찾지 못할 때만 전역 스코프에서 찾는다. 

### 함수 호이스팅

코드를 선언과 할당으로 분리해 선언부를 자신의 스코프 최상위로 끌어올리는 것을 말한다. 함수도 호이스팅 된다. 함수 표현식은 변수를 선언한 부분이기 때문에 호이스팅이 일어나지 않음. 그이유는 ```var func = function hllo()```이렇게 선언하기 때문에 `var func`만 최상단으로 올려져서 `func()`가 먼저오면 is not a function 오류를 출력한다. 화살표 함수도 같은 원리

# 즉시 실행 함수

즉시 실행 함수 IIFE 함수를 정의하면서 동시에 실행하는 함수
형식`(function() {})()` function 자체가 소괄호로 한 번 감싸짐. 한 번 실행되고 나면 메모리에 데이터가 남아 있지 않는다. 그래서 식별자도 한 번도 사용되지 않은 것 처럼 인식된다. 그래서 즉시 실행 함수를 호출한 다음 재호출하면 not define 오류를 발생시킴.

